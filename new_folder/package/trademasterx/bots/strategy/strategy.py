"""
TradeMasterX 2.0 - Strategy Bot
Advanced trading strategy implementation and execution system.
"""

import json
import logging
import asyncio
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
import numpy as np

from ...core.bot_registry import BaseBot


class SignalType(Enum):
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    STRONG_BUY = "STRONG_BUY"
    STRONG_SELL = "STRONG_SELL"


class StrategyType(Enum):
    MOMENTUM = "momentum"
    MEAN_REVERSION = "mean_reversion"
    BREAKOUT = "breakout"
    ARBITRAGE = "arbitrage"
    SCALPING = "scalping"


@dataclass
class TradingSignal:
    """Trading signal generated by strategy"""
    symbol: str
    signal_type: SignalType
    confidence: float
    entry_price: float
    stop_loss: Optional[float]
    take_profit: Optional[float]
    timeframe: str
    strategy_name: str
    timestamp: datetime
    metadata: Dict[str, Any]


@dataclass
class PositionSizing:
    """Position sizing calculation result"""
    symbol: str
    recommended_size: float
    max_size: float
    risk_percentage: float
    calculated_leverage: float
    reasoning: str


@dataclass
class StrategyPerformance:
    """Strategy performance metrics"""
    strategy_name: str
    total_signals: int
    successful_signals: int
    win_rate: float
    avg_return: float
    max_drawdown: float
    sharpe_ratio: float
    total_return: float
    active_positions: int


class StrategyBot(BaseBot):
    """
    Advanced Strategy Bot for TradeMasterX 2.0
    
    Provides:
    - Multi-strategy signal generation
    - Position sizing and risk management
    - Real-time market analysis    - Strategy performance tracking
    - Dynamic strategy allocation
    """
    
    def __init__(self, name: str, config: Dict[str, Any]):
        # If no config is provided, load default configuration
        if config is None:
            from ...config.config_loader import ConfigLoader
            config_loader = ConfigLoader()
            config = config_loader.get_config('strategies', {})
        
        super().__init__(name, config)
        
        # Strategy configuration
        self.enabled_strategies = config.get('enabled_strategies', ['momentum', 'mean_reversion'])
        self.max_positions = config.get('max_positions', 10)
        self.risk_per_trade = config.get('risk_per_trade', 0.02)  # 2% per trade
        self.max_portfolio_risk = config.get('max_portfolio_risk', 0.15)  # 15% total
        
        # Timeframes to analyze
        self.timeframes = config.get('timeframes', ['1m', '5m', '15m', '1h', '4h'])
        self.primary_timeframe = config.get('primary_timeframe', '15m')
        
        # Strategy parameters
        self.strategy_params = config.get('strategy_params', {
            'momentum': {
                'rsi_period': 14,
                'rsi_overbought': 70,
                'rsi_oversold': 30,
                'ma_fast': 9,
                'ma_slow': 21
            },
            'mean_reversion': {
                'bb_period': 20,
                'bb_std': 2,
                'rsi_period': 14,
                'oversold_threshold': 20,
                'overbought_threshold': 80
            },
            'breakout': {
                'resistance_touches': 3,
                'support_touches': 3,
                'volume_multiplier': 1.5,
                'min_breakout_strength': 0.8
            }
        })
        
        # Data storage
        self.market_data: Dict[str, Dict] = {}
        self.active_signals: List[TradingSignal] = []
        self.strategy_performance: Dict[str, StrategyPerformance] = {}
        self.position_sizes: Dict[str, PositionSizing] = {}
        
        # Trading state
        self.portfolio_risk = 0.0
        self.active_positions = 0
        self.last_signal_time = {}
        
        self.logger.info(f"StrategyBot {name} configured with {len(self.enabled_strategies)} strategies")

    async def initialize(self) -> bool:
        """Initialize strategy bot resources"""
        try:
            # Initialize strategy performance tracking
            for strategy in self.enabled_strategies:
                self.strategy_performance[strategy] = StrategyPerformance(
                    strategy_name=strategy,
                    total_signals=0,
                    successful_signals=0,
                    win_rate=0.0,
                    avg_return=0.0,
                    max_drawdown=0.0,
                    sharpe_ratio=0.0,
                    total_return=0.0,
                    active_positions=0
                )
            
            # Validate strategy parameters
            if await self._validate_strategy_config():
                self.is_initialized = True
                self.logger.info("StrategyBot initialized successfully")
                return True
            else:
                self.logger.error("Strategy configuration validation failed")
                return False
                
        except Exception as e:
            self.logger.error(f"StrategyBot initialization failed: {e}")
            return False

    async def execute_cycle(self) -> Dict[str, Any]:
        """Execute complete strategy cycle"""
        try:
            self.logger.info("📊 Starting strategy execution cycle...")
            
            # Update market data
            await self._update_market_data()
            
            # Generate signals from all enabled strategies
            new_signals = await self.generate_signals()
            
            # Calculate position sizing for new signals
            position_results = await self.calculate_position_sizing(new_signals)
            
            # Update strategy performance
            performance_update = await self.update_strategy_performance()
            
            # Risk management check
            risk_analysis = await self.analyze_portfolio_risk()
            
            cycle_result = {
                "timestamp": datetime.now().isoformat(),
                "new_signals": [asdict(s) for s in new_signals],
                "position_sizing": position_results,
                "strategy_performance": performance_update,
                "risk_analysis": risk_analysis,
                "portfolio_status": {
                    "active_positions": self.active_positions,
                    "portfolio_risk": self.portfolio_risk,
                    "max_positions": self.max_positions
                },
                "status": "success"
            }
            
            # Save results
            await self._save_strategy_results(cycle_result)
            
            self.logger.info(f"✅ Strategy cycle completed - Generated {len(new_signals)} signals")
            return cycle_result
            
        except Exception as e:
            self.logger.error(f"Strategy cycle error: {e}")
            return {
                "timestamp": datetime.now().isoformat(),
                "status": "error",
                "error": str(e)
            }

    async def generate_signals(self) -> List[TradingSignal]:
        """
        Generate trading signals from all enabled strategies
        
        Returns:
            List of trading signals with confidence scores
        """
        try:
            self.logger.info(f"🔍 Generating signals from {len(self.enabled_strategies)} strategies...")
            
            all_signals = []
            
            for strategy_name in self.enabled_strategies:
                strategy_signals = await self._execute_strategy(strategy_name)
                all_signals.extend(strategy_signals)
            
            # Filter and rank signals
            filtered_signals = self._filter_signals(all_signals)
            ranked_signals = self._rank_signals(filtered_signals)
            
            # Update active signals
            self.active_signals = ranked_signals
            
            self.logger.info(f"Generated {len(ranked_signals)} high-quality signals")
            return ranked_signals
            
        except Exception as e:
            self.logger.error(f"Signal generation error: {e}")
            return []

    async def calculate_position_sizing(self, signals: List[TradingSignal]) -> Dict[str, Any]:
        """
        Calculate optimal position sizing for trading signals
        
        Args:
            signals: List of trading signals to size
            
        Returns:
            Dict containing position sizing recommendations
        """
        try:
            self.logger.info(f"💰 Calculating position sizing for {len(signals)} signals...")
            
            sizing_results = {}
            
            for signal in signals:
                # Calculate position size based on risk management
                position_size = self._calculate_kelly_sizing(signal)
                
                # Apply portfolio risk limits
                adjusted_size = self._apply_risk_limits(signal, position_size)
                
                # Create position sizing object
                sizing = PositionSizing(
                    symbol=signal.symbol,
                    recommended_size=adjusted_size,
                    max_size=position_size,
                    risk_percentage=self.risk_per_trade,
                    calculated_leverage=self._calculate_leverage(signal, adjusted_size),
                    reasoning=self._generate_sizing_reasoning(signal, position_size, adjusted_size)
                )
                
                sizing_results[signal.symbol] = asdict(sizing)
                self.position_sizes[signal.symbol] = sizing
            
            result = {
                "total_signals_sized": len(signals),
                "position_sizing": sizing_results,
                "risk_utilization": self.portfolio_risk / self.max_portfolio_risk,
                "available_capacity": max(0, self.max_positions - self.active_positions)
            }
            
            self.logger.info(f"Position sizing completed for {len(sizing_results)} signals")
            return result
            
        except Exception as e:
            self.logger.error(f"Position sizing error: {e}")
            return {"error": str(e)}

    async def update_strategy_performance(self) -> Dict[str, Any]:
        """
        Update performance metrics for all strategies
        
        Returns:
            Dict containing updated performance metrics
        """
        try:
            self.logger.info("📈 Updating strategy performance metrics...")
            
            performance_data = {}
            
            for strategy_name in self.enabled_strategies:
                # Get recent performance data for this strategy
                recent_performance = await self._calculate_recent_performance(strategy_name)
                
                # Update strategy performance object
                if strategy_name in self.strategy_performance:
                    perf = self.strategy_performance[strategy_name]
                    
                    # Update metrics
                    perf.total_signals = recent_performance.get('total_signals', perf.total_signals)
                    perf.successful_signals = recent_performance.get('successful_signals', perf.successful_signals)
                    perf.win_rate = recent_performance.get('win_rate', perf.win_rate)
                    perf.avg_return = recent_performance.get('avg_return', perf.avg_return)
                    perf.max_drawdown = recent_performance.get('max_drawdown', perf.max_drawdown)
                    perf.sharpe_ratio = recent_performance.get('sharpe_ratio', perf.sharpe_ratio)
                    perf.total_return = recent_performance.get('total_return', perf.total_return)
                    perf.active_positions = recent_performance.get('active_positions', perf.active_positions)
                    
                    performance_data[strategy_name] = asdict(perf)
            
            # Calculate strategy rankings
            rankings = self._rank_strategies(performance_data)
            
            result = {
                "strategy_performance": performance_data,
                "strategy_rankings": rankings,
                "best_performing_strategy": rankings[0] if rankings else None,
                "overall_portfolio_return": sum(p.get('total_return', 0) for p in performance_data.values())
            }
            
            self.logger.info("Strategy performance updated successfully")
            return result
            
        except Exception as e:
            self.logger.error(f"Strategy performance update error: {e}")
            return {"error": str(e)}

    async def analyze_portfolio_risk(self) -> Dict[str, Any]:
        """
        Analyze current portfolio risk and exposure
        
        Returns:
            Dict containing risk analysis results
        """
        try:
            self.logger.info("⚠️ Analyzing portfolio risk...")
            
            # Calculate current exposures
            total_exposure = sum(pos.recommended_size for pos in self.position_sizes.values())
            correlation_risk = self._calculate_correlation_risk()
            sector_concentration = self._calculate_sector_concentration()
            
            # Risk metrics
            var_1d = self._calculate_value_at_risk('1d')
            var_7d = self._calculate_value_at_risk('7d')
            
            # Risk warnings
            warnings = []
            if self.portfolio_risk > self.max_portfolio_risk * 0.8:
                warnings.append("Portfolio risk approaching maximum limit")
            
            if correlation_risk > 0.7:
                warnings.append("High correlation risk detected between positions")
            
            if sector_concentration > 0.5:
                warnings.append("High sector concentration risk")
            
            risk_analysis = {
                "portfolio_risk_percentage": round(self.portfolio_risk * 100, 2),
                "max_risk_percentage": round(self.max_portfolio_risk * 100, 2),
                "risk_utilization": round(self.portfolio_risk / self.max_portfolio_risk * 100, 2),
                "total_exposure": total_exposure,
                "correlation_risk": round(correlation_risk, 3),
                "sector_concentration": round(sector_concentration, 3),
                "value_at_risk": {
                    "1_day": round(var_1d, 4),
                    "7_day": round(var_7d, 4)
                },
                "active_positions": self.active_positions,
                "max_positions": self.max_positions,
                "warnings": warnings,
                "risk_status": "HIGH" if warnings else "NORMAL"
            }
            
            self.logger.info(f"Risk analysis completed - Status: {risk_analysis['risk_status']}")
            return risk_analysis
            
        except Exception as e:
            self.logger.error(f"Risk analysis error: {e}")
            return {"error": str(e)}

    async def cleanup(self):
        """Cleanup strategy bot resources"""
        try:
            # Clear cached data
            self.market_data.clear()
            self.active_signals.clear()
            self.position_sizes.clear()
            
            # Reset state
            self.portfolio_risk = 0.0
            self.active_positions = 0
            
            self.logger.info("StrategyBot cleaned up")
            
        except Exception as e:
            self.logger.error(f"StrategyBot cleanup error: {e}")

    # Private helper methods
    
    async def _validate_strategy_config(self) -> bool:
        """Validate strategy configuration"""
        try:
            # Check if all enabled strategies have parameters
            for strategy in self.enabled_strategies:
                if strategy not in self.strategy_params:
                    self.logger.error(f"Missing parameters for strategy: {strategy}")
                    return False
            
            # Validate risk parameters
            if self.risk_per_trade <= 0 or self.risk_per_trade > 0.1:
                self.logger.error("Risk per trade must be between 0 and 10%")
                return False
            
            if self.max_portfolio_risk <= 0 or self.max_portfolio_risk > 0.5:
                self.logger.error("Max portfolio risk must be between 0 and 50%")
                return False
            
            return True
            
        except Exception as e:
            self.logger.error(f"Strategy config validation error: {e}")
            return False

    async def _update_market_data(self):
        """Update market data for all symbols and timeframes"""
        try:
            # This would typically fetch real market data
            # For now, we'll simulate the structure
            
            symbols = ['BTCUSDT', 'ETHUSDT', 'ADAUSDT', 'DOTUSDT']  # Example symbols
            
            for symbol in symbols:
                self.market_data[symbol] = {
                    'price': np.random.uniform(100, 50000),  # Simulated price
                    'volume': np.random.uniform(1000000, 10000000),
                    'high_24h': np.random.uniform(100, 55000),
                    'low_24h': np.random.uniform(95, 45000),
                    'change_24h': np.random.uniform(-5, 5),
                    'timestamp': datetime.now()
                }
            
            self.logger.debug(f"Updated market data for {len(symbols)} symbols")
            
        except Exception as e:
            self.logger.error(f"Market data update error: {e}")

    async def _execute_strategy(self, strategy_name: str) -> List[TradingSignal]:
        """Execute a specific strategy and generate signals"""
        try:
            if strategy_name == 'momentum':
                return await self._momentum_strategy()
            elif strategy_name == 'mean_reversion':
                return await self._mean_reversion_strategy()
            elif strategy_name == 'breakout':
                return await self._breakout_strategy()
            else:
                self.logger.warning(f"Unknown strategy: {strategy_name}")
                return []
                
        except Exception as e:
            self.logger.error(f"Strategy execution error for {strategy_name}: {e}")
            return []

    async def _momentum_strategy(self) -> List[TradingSignal]:
        """Momentum-based trading strategy"""
        signals = []
        params = self.strategy_params.get('momentum', {})
        
        try:
            for symbol, data in self.market_data.items():
                # Simulated momentum calculation
                price_change = data.get('change_24h', 0)
                volume_ratio = data.get('volume', 0) / 1000000  # Normalize volume
                
                # Generate signal based on momentum
                if price_change > 3 and volume_ratio > 2:  # Strong upward momentum
                    signal = TradingSignal(
                        symbol=symbol,
                        signal_type=SignalType.BUY,
                        confidence=min(0.95, (price_change + volume_ratio) / 10),
                        entry_price=data['price'],
                        stop_loss=data['price'] * 0.95,  # 5% stop loss
                        take_profit=data['price'] * 1.08,  # 8% take profit
                        timeframe=self.primary_timeframe,
                        strategy_name='momentum',
                        timestamp=datetime.now(),
                        metadata={
                            'price_change_24h': price_change,
                            'volume_ratio': volume_ratio,
                            'signal_strength': 'strong'
                        }
                    )
                    signals.append(signal)
                    
                elif price_change < -3 and volume_ratio > 2:  # Strong downward momentum
                    signal = TradingSignal(
                        symbol=symbol,
                        signal_type=SignalType.SELL,
                        confidence=min(0.95, abs(price_change + volume_ratio) / 10),
                        entry_price=data['price'],
                        stop_loss=data['price'] * 1.05,  # 5% stop loss for short
                        take_profit=data['price'] * 0.92,  # 8% take profit for short
                        timeframe=self.primary_timeframe,
                        strategy_name='momentum',
                        timestamp=datetime.now(),
                        metadata={
                            'price_change_24h': price_change,
                            'volume_ratio': volume_ratio,
                            'signal_strength': 'strong'
                        }
                    )
                    signals.append(signal)
                    
        except Exception as e:
            self.logger.error(f"Momentum strategy error: {e}")
        
        return signals

    async def _mean_reversion_strategy(self) -> List[TradingSignal]:
        """Mean reversion trading strategy"""
        signals = []
        params = self.strategy_params.get('mean_reversion', {})
        
        try:
            for symbol, data in self.market_data.items():
                # Simulated mean reversion calculation
                current_price = data['price']
                high_24h = data.get('high_24h', current_price)
                low_24h = data.get('low_24h', current_price)
                
                # Calculate price position within range
                if high_24h != low_24h:
                    price_position = (current_price - low_24h) / (high_24h - low_24h)
                    
                    # Mean reversion signals
                    if price_position > 0.8:  # Near resistance, expect reversion down
                        signal = TradingSignal(
                            symbol=symbol,
                            signal_type=SignalType.SELL,
                            confidence=0.7,
                            entry_price=current_price,
                            stop_loss=current_price * 1.03,
                            take_profit=current_price * 0.95,
                            timeframe=self.primary_timeframe,
                            strategy_name='mean_reversion',
                            timestamp=datetime.now(),
                            metadata={
                                'price_position': price_position,
                                'high_24h': high_24h,
                                'low_24h': low_24h,
                                'reversion_type': 'resistance'
                            }
                        )
                        signals.append(signal)
                        
                    elif price_position < 0.2:  # Near support, expect reversion up
                        signal = TradingSignal(
                            symbol=symbol,
                            signal_type=SignalType.BUY,
                            confidence=0.7,
                            entry_price=current_price,
                            stop_loss=current_price * 0.97,
                            take_profit=current_price * 1.05,
                            timeframe=self.primary_timeframe,
                            strategy_name='mean_reversion',
                            timestamp=datetime.now(),
                            metadata={
                                'price_position': price_position,
                                'high_24h': high_24h,
                                'low_24h': low_24h,
                                'reversion_type': 'support'
                            }
                        )
                        signals.append(signal)
                        
        except Exception as e:
            self.logger.error(f"Mean reversion strategy error: {e}")
        
        return signals

    async def _breakout_strategy(self) -> List[TradingSignal]:
        """Breakout trading strategy"""
        signals = []
        params = self.strategy_params.get('breakout', {})
        
        try:
            for symbol, data in self.market_data.items():
                # Simulated breakout detection
                current_price = data['price']
                high_24h = data.get('high_24h', current_price)
                low_24h = data.get('low_24h', current_price)
                volume_ratio = data.get('volume', 0) / 1000000
                
                # Breakout above resistance
                if current_price >= high_24h * 0.995 and volume_ratio > 1.5:
                    signal = TradingSignal(
                        symbol=symbol,
                        signal_type=SignalType.STRONG_BUY,
                        confidence=0.85,
                        entry_price=current_price,
                        stop_loss=high_24h * 0.95,
                        take_profit=current_price * 1.12,
                        timeframe=self.primary_timeframe,
                        strategy_name='breakout',
                        timestamp=datetime.now(),
                        metadata={
                            'breakout_type': 'resistance',
                            'resistance_level': high_24h,
                            'volume_confirmation': volume_ratio > 1.5,
                            'breakout_strength': (current_price / high_24h - 1) * 100
                        }
                    )
                    signals.append(signal)
                    
                # Breakdown below support
                elif current_price <= low_24h * 1.005 and volume_ratio > 1.5:
                    signal = TradingSignal(
                        symbol=symbol,
                        signal_type=SignalType.STRONG_SELL,
                        confidence=0.85,
                        entry_price=current_price,
                        stop_loss=low_24h * 1.05,
                        take_profit=current_price * 0.88,
                        timeframe=self.primary_timeframe,
                        strategy_name='breakout',
                        timestamp=datetime.now(),
                        metadata={
                            'breakout_type': 'support',
                            'support_level': low_24h,
                            'volume_confirmation': volume_ratio > 1.5,
                            'breakdown_strength': (1 - current_price / low_24h) * 100
                        }
                    )
                    signals.append(signal)
                    
        except Exception as e:
            self.logger.error(f"Breakout strategy error: {e}")
        
        return signals

    def _filter_signals(self, signals: List[TradingSignal]) -> List[TradingSignal]:
        """Filter signals based on quality criteria"""
        filtered = []
        
        for signal in signals:
            # Minimum confidence threshold
            if signal.confidence < 0.6:
                continue
                
            # Check if we already have a recent signal for this symbol
            symbol_last_signal = self.last_signal_time.get(signal.symbol)
            if symbol_last_signal:
                time_diff = (datetime.now() - symbol_last_signal).total_seconds()
                if time_diff < 300:  # 5 minutes minimum between signals
                    continue
            
            filtered.append(signal)
            self.last_signal_time[signal.symbol] = signal.timestamp
        
        return filtered

    def _rank_signals(self, signals: List[TradingSignal]) -> List[TradingSignal]:
        """Rank signals by quality and confidence"""
        return sorted(signals, key=lambda s: s.confidence, reverse=True)

    def _calculate_kelly_sizing(self, signal: TradingSignal) -> float:
        """Calculate Kelly criterion position sizing"""
        try:
            # Simulated Kelly calculation based on signal confidence
            win_rate = signal.confidence
            avg_win = 0.08  # Average 8% win
            avg_loss = 0.04  # Average 4% loss
            
            kelly_f = (win_rate * avg_win - (1 - win_rate) * avg_loss) / avg_win
            
            # Apply conservative factor
            conservative_kelly = kelly_f * 0.25  # Use 25% of Kelly
            
            return max(0.01, min(0.1, conservative_kelly))  # Between 1% and 10%
            
        except Exception as e:
            self.logger.error(f"Kelly sizing calculation error: {e}")
            return 0.02  # Default 2%

    def _apply_risk_limits(self, signal: TradingSignal, position_size: float) -> float:
        """Apply portfolio-level risk limits to position sizing"""
        try:
            # Check if adding this position would exceed portfolio risk
            additional_risk = position_size
            
            if self.portfolio_risk + additional_risk > self.max_portfolio_risk:
                # Reduce position size to fit within risk limit
                available_risk = self.max_portfolio_risk - self.portfolio_risk
                adjusted_size = max(0, available_risk)
            else:
                adjusted_size = position_size
            
            # Check position count limit
            if self.active_positions >= self.max_positions:
                adjusted_size = 0
            
            return adjusted_size
            
        except Exception as e:
            self.logger.error(f"Risk limits application error: {e}")
            return 0

    def _calculate_leverage(self, signal: TradingSignal, position_size: float) -> float:
        """Calculate appropriate leverage for the position"""
        # Conservative leverage based on confidence
        base_leverage = 1.0
        confidence_multiplier = signal.confidence
        
        # Higher confidence allows slightly higher leverage
        max_leverage = 2.0 if confidence_multiplier > 0.8 else 1.5
        
        calculated_leverage = min(max_leverage, base_leverage + confidence_multiplier)
        return round(calculated_leverage, 2)

    def _generate_sizing_reasoning(self, signal: TradingSignal, 
                                 original_size: float, adjusted_size: float) -> str:
        """Generate human-readable reasoning for position sizing"""
        if adjusted_size == 0:
            if self.active_positions >= self.max_positions:
                return "Position limit reached"
            else:
                return "Portfolio risk limit reached"
        elif adjusted_size < original_size:
            return f"Size reduced from {original_size:.2%} to {adjusted_size:.2%} due to risk limits"
        else:
            return f"Optimal size based on {signal.confidence:.1%} confidence and Kelly criterion"

    async def _calculate_recent_performance(self, strategy_name: str) -> Dict[str, Any]:
        """Calculate recent performance for a strategy"""
        # This would typically pull from historical trade data
        # For now, return simulated performance
        return {
            'total_signals': np.random.randint(50, 200),
            'successful_signals': np.random.randint(30, 140),
            'win_rate': np.random.uniform(0.55, 0.75),
            'avg_return': np.random.uniform(0.02, 0.08),
            'max_drawdown': np.random.uniform(0.05, 0.15),
            'sharpe_ratio': np.random.uniform(1.2, 2.5),
            'total_return': np.random.uniform(0.1, 0.4),
            'active_positions': np.random.randint(0, 5)
        }

    def _rank_strategies(self, performance_data: Dict[str, Any]) -> List[str]:
        """Rank strategies by performance"""
        strategy_scores = []
        
        for strategy_name, perf in performance_data.items():
            # Calculate composite score
            score = (
                perf.get('win_rate', 0) * 40 +
                perf.get('sharpe_ratio', 0) / 3 * 30 +
                max(0, 1 - perf.get('max_drawdown', 1)) * 20 +
                perf.get('total_return', 0) * 10
            )
            strategy_scores.append((strategy_name, score))
        
        # Sort by score descending
        strategy_scores.sort(key=lambda x: x[1], reverse=True)
        
        return [name for name, score in strategy_scores]

    def _calculate_correlation_risk(self) -> float:
        """Calculate correlation risk between positions"""
        # Simplified correlation calculation
        if len(self.position_sizes) < 2:
            return 0.0
        
        # Simulate correlation risk based on symbol similarities
        symbols = list(self.position_sizes.keys())
        correlations = []
        
        for i in range(len(symbols)):
            for j in range(i+1, len(symbols)):
                # Simulate correlation (would use real price data in practice)
                correlation = np.random.uniform(0.3, 0.8)
                correlations.append(correlation)
        
        return np.mean(correlations) if correlations else 0.0

    def _calculate_sector_concentration(self) -> float:
        """Calculate sector concentration risk"""
        if not self.position_sizes:
            return 0.0
        
        # Simplified sector grouping (would use real sector data)
        crypto_symbols = sum(1 for symbol in self.position_sizes.keys() if 'USDT' in symbol)
        total_positions = len(self.position_sizes)
        
        return crypto_symbols / total_positions if total_positions > 0 else 0.0

    def _calculate_value_at_risk(self, timeframe: str) -> float:
        """Calculate Value at Risk for given timeframe"""
        if not self.position_sizes:
            return 0.0
        
        # Simplified VaR calculation
        total_exposure = sum(pos.recommended_size for pos in self.position_sizes.values())
        
        # Simulate volatility based on timeframe
        if timeframe == '1d':
            volatility = 0.03  # 3% daily volatility
        elif timeframe == '7d':
            volatility = 0.08  # 8% weekly volatility
        else:
            volatility = 0.02
        
        # 95% confidence level VaR
        confidence_level = 1.645  # 95% confidence
        var = total_exposure * volatility * confidence_level
        
        return var

    async def _save_strategy_results(self, results: Dict[str, Any]):
        """Save strategy results to file"""
        try:
            results_dir = Path("data/strategy")
            results_dir.mkdir(parents=True, exist_ok=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            results_file = results_dir / f"strategy_{timestamp}.json"
            
            with open(results_file, 'w') as f:
                json.dump(results, f, indent=2, default=str)
            
            self.logger.info(f"Strategy results saved: {results_file}")
            
        except Exception as e:
            self.logger.error(f"Results saving error: {e}")


# Register the strategy bot
from . import register_strategy_bot
register_strategy_bot("strategy", StrategyBot)
